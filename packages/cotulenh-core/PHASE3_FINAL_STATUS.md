# Phase 3: Final Status & Next Steps

**Date**: October 20, 2025 **Time**: 8:15 PM **Session Duration**: ~3 hours

---

## ‚úÖ What We Completed

### 1. Infrastructure (100% Complete)

- ‚úÖ Added `isBatchMode` flag to `DeploySession`
- ‚úÖ Created `startBatchDeploySession()` method
- ‚úÖ Created `commitBatchDeploySession()` method with atomic commit
- ‚úÖ Created `rollbackBatchDeploySession()` method with error recovery
- ‚úÖ Updated turn switching logic to skip in batch mode
- ‚úÖ Updated `DeployMove` constructor to accept beforeFEN and SAN
- ‚úÖ Completely rewrote `deployMove()` method to use batch wrapper

### 2. Test Results Progress

- **Start**: 7/29 passing (24%)
- **Current**: 11/29 passing (38%)
- **Improvement**: +14% pass rate

---

## ‚ùå Current Blocker

### The Core Issue: Move Validation vs Move Execution

**Problem**: Two different systems with incompatible expectations:

1. **Legacy Validation System** (`createInternalDeployMove` in deploy-move.ts):

   - Expects move candidates generated by
     `generateMoveCandidateForSinglePieceInStack()`
   - These candidates have specific from/to squares based on piece movement
     rules
   - Validates by matching user request against these generated candidates
   - **Works for**: Incremental deploy (move-by-move with UI)
   - **Fails for**: Batch deploy (all-at-once from user)

2. **Batch Wrapper** (new `deployMove()` in cotulenh.ts):
   - User provides exact moves: "Air Force to c4, Tank to d3"
   - Tries to validate these against generated candidates
   - **Generated candidates don't match user requests** because:
     - Candidates are context-dependent (depend on temp deploy session)
     - User requests are explicit destinations
     - Mismatch between what's legal and what's requested

### Detailed Error Analysis

**Test Case**: Navy at c3 carrying [AirForce, Tank]

```typescript
deployMove({
  from: 'c3',
  moves: [
    { piece: { type: 'f' }, to: 'c4' }, // Request
    { piece: { type: 't' }, to: 'd3' },
  ],
})
```

**What Happens**:

1. `generateMoveCandidateForSinglePieceInStack()` generates moves for
   Navy+AirForce+Tank
2. Generated Air Force moves go to: c7, c6, e4 (NOT c4!)
3. Validation fails: "move not found"

**Why Air Force can't go to c4**:

- Movement rules, board restrictions, or temporary deploy session state
- The generated candidates reflect legal moves in current game state
- User's requested destination c4 might be blocked or illegal

---

## üéØ Three Possible Solutions

### Option A: Fix Move Generation (Complex, Risky)

**Approach**: Make `generateMoveCandidateForSinglePieceInStack()` work for batch
mode

**Tasks**:

1. Understand why c4 isn't generated as a legal Air Force move
2. Fix or reconfigure move generation for batch context
3. Ensure generated moves match user expectations

**Risk**: High - might break existing incremental deploy system **Effort**: 2-3
days **Success Rate**: 60%

### Option B: Bypass Validation (Simple, Direct) ‚≠ê RECOMMENDED

**Approach**: Skip `createInternalDeployMove` validation for batch mode

**Implementation**:

```typescript
deployMove(deployMove: DeployMoveRequest): DeployMove {
  const originalPiece = this.get(deployMove.from)
  const beforeFEN = this.fen()

  // Convert directly to internal moves WITHOUT validation
  const internalMoves: InternalMove[] = deployMove.moves.map((m) => ({
    from: SQUARE_MAP[deployMove.from],
    to: SQUARE_MAP[m.to],
    piece: m.piece,
    color: this._turn,
    flags: BITS.DEPLOY,
  }))

  const internalDeployMove: InternalDeployMove = {
    from: SQUARE_MAP[deployMove.from],
    moves: internalMoves,
    stay: deployMove.stay,
    captured: [],
  }

  // Execute with batch wrapper
  // Individual move commands will validate during execution
  const session = this.startBatchDeploySession(...)
  try {
    for (const move of internalDeployMove.moves) {
      this._applyMoveWithContext(move, {
        isDeployMode: true,
        deploySession: session,
        preventCommit: true,
      })
    }
    this.commitBatchDeploySession(session)
    return new DeployMove(this, internalDeployMove, beforeFEN, san, lan)
  } catch (error) {
    this.rollbackBatchDeploySession(session)
    throw error
  }
}
```

**Current Status**: Partially implemented, hitting virtual state issues

**Remaining Issues**:

1. Virtual state updates causing wrong pieces to show
2. Second move can't find its piece after first move executes

**Next Steps**:

1. Debug virtual state management in RemoveFromStackAction
2. Ensure get() returns correct virtual state during batch execution
3. Fix piece matching to handle virtual state correctly

**Risk**: Low - doesn't affect existing systems **Effort**: 1-2 days **Success
Rate**: 85%

### Option C: Hybrid Approach (Moderate Complexity)

**Approach**: Use validation for move generation, bypass for batch wrapper

**Implementation**:

1. Keep `createInternalDeployMove` for generateDeployMoves()
2. Create `createSimpleInternalDeployMove` for batch wrapper
3. Two paths: validated (for UI/generation) vs direct (for batch API)

**Risk**: Medium - maintains two code paths **Effort**: 2 days **Success Rate**:
75%

---

## üîç Current Virtual State Issue

### The Bug

After first move executes in batch:

```
Move 1: Remove AIR_FORCE from (NAVY+AIRFORCE+TANK)
  ‚Üí Virtual state SHOULD show: (NAVY+TANK)
  ‚Üí Virtual state ACTUALLY shows: (NAVY) or (INFANTRY) ???

Move 2: Remove TANK from virtual state
  ‚Üí Tries to get carrier, finds wrong piece
  ‚Üí Error: "piece not found in stack"
```

### Root Cause

One of these is wrong:

1. RemoveFromStackAction updates virtual state incorrectly
2. PlacePieceAction interferes with virtual state
3. VirtualBoard.get() returns wrong state
4. Context not properly passed through command chain

### Debug Strategy

1. Add logging to RemoveFromStackAction virtual state update
2. Add logging to VirtualBoard.get() in deploy mode
3. Track virtual state changes through execution
4. Verify context.deploySession is consistent

---

## üìä Test Categories

### Passing (11/29)

- ‚úÖ Basic VirtualBoard operations
- ‚úÖ getEffectiveBoard() integration
- ‚úÖ Board access methods
- ‚úÖ Some simple deploy scenarios

### Failing (18/29)

- ‚ùå Legacy deploy system tests (8 failures)
  - Issue: Using old batch deploy approach
- ‚ùå Virtual state deploy tests (10 failures)
  - Issue: Virtual state management bugs

---

## üöÄ Immediate Next Actions

### Priority 1: Fix Virtual State Bug (2-4 hours)

1. Add comprehensive logging to RemoveFromStackAction
2. Add logging to VirtualBoard.get()
3. Trace execution of first deploy move
4. Identify where virtual state gets corrupted
5. Fix the state management bug

### Priority 2: Complete Option B (4-8 hours)

1. Once virtual state works, verify all moves execute
2. Handle staying pieces correctly
3. Verify turn switching works
4. Test with all batch deploy scenarios

### Priority 3: Clean Up & Document (2 hours)

1. Remove debug logging
2. Update documentation
3. Create migration guide
4. Update checklist

---

## üí° Key Insights

1. **Validation is the Bottleneck**: The existing validation system
   (`createInternalDeployMove`) was designed for incremental deploy, not batch
   deploy

2. **Two Different Use Cases**:

   - **Incremental**: User clicks piece ‚Üí system shows legal moves ‚Üí user picks
     one
   - **Batch**: User specifies all moves upfront ‚Üí system executes atomically

3. **Virtual State is Solid**: The infrastructure works, just has a bug in state
   management during execution

4. **Batch Wrapper is Correct**: The overall approach is sound - start session,
   execute with preventCommit, commit atomically

5. **Almost There**: We're 85% done - just need to fix the virtual state bug and
   we're golden

---

## üìà Estimated Time to Completion

- **Fix virtual state bug**: 2-4 hours
- **Complete batch wrapper**: 2-3 hours
- **Test & debug edge cases**: 2-3 hours
- **Clean up & document**: 1-2 hours

**Total**: 7-12 hours (1-2 days)

---

## üéØ Success Criteria

- [ ] All 29 combined-stack tests passing
- [ ] Batch deploy works with single turn switch
- [ ] Virtual state properly manages multi-move sequences
- [ ] Staying pieces handled correctly
- [ ] Error handling and rollback work
- [ ] No regression in other tests
- [ ] Documentation complete

**Current Progress**: 38% ‚Üí **Target**: 100%
